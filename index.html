<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arc‑Fractal Tree — Play with 3D Curved Trees</title>
  <meta name="description" content="Interactive 3D arc‑fractal tree playground built with Three.js. Tweak depth, branching, tilt, and scaling presets (golden, silver, plastic)." />
  <meta property="og:title" content="Arc‑Fractal Tree" />
  <meta property="og:description" content="Play with a 3D arc‑fractal tree — adjust depth, branching, tilt, and φ/silver/plastic scaling presets." />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://dummyimage.com/1200x630/0b0e13/ffffff&text=Arc‑Fractal+Tree" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%8C%B3%3C/text%3E%3C/svg%3E" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background:#0b0e13; color:#e7eaee; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; }
    .overlay { position: fixed; left: 12px; top: 12px; z-index: 10; display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .btn { appearance:none; border:1px solid #2a3240; background:#12161c; color:#dfe6f1; padding:6px 10px; border-radius:10px; cursor:pointer; font-size:12px }
    .btn:hover{ background:#161c24; }
    .hint { position: fixed; left: 12px; bottom: 12px; opacity: 0.75; font-size: 12px; }
    .brand { position: fixed; right: 12px; bottom: 12px; opacity: 0.8; font-size: 12px; color:#b9c0c9; }
    @media (max-width: 640px){ .hint{ max-width: 70vw; } }
  </style>

  <!-- Import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "lil-gui": "https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="overlay">
    <button id="resetBtn" class="btn">Reset view</button>
    <button id="shareBtn" class="btn">Share link</button>
    <button id="randomBtn" class="btn">Randomize</button>
  </div>
  <div class="hint">Drag = orbit · Shift+Drag = pan · Wheel/pinch = zoom · Press <b>S</b> to save a PNG</div>
  <div class="brand">Arc‑Fractal Tree · Three.js · <a href="#" id="aboutLink" style="color:#9ecbff">About</a></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import GUI from 'lil-gui';

    // ---------- Utilities for URL params ----------
    function readParams(){
      const p = new URLSearchParams(location.search);
      const num = (k, d, f=x=>+x) => p.has(k) ? f(p.get(k)) : d;
      const str = (k, d) => p.has(k) ? p.get(k) : d;
      return {
        depth: num('depth', 1, x=>Math.max(0, Math.min(7, parseInt(x,10)||1))),
        arcAngleDeg: num('angle', 60),
        branchAzimuthDeg: num('step', 60),
        branchesPerSplit: num('bps', 6, x=>Math.max(1, parseInt(x,10)||6)),
        lockBranchesToAzimuth: str('lock','1') !== '0',
        scalePreset: str('preset', 'phi^-1'),
        scalePerLevel: num('scale', NaN),
        thickness: num('thick', 0.1),
        radiusStart: num('r0', 1.2),
        tubularSegments: num('seg', 36),
        radialSegments: num('sides', 10),
        tiltDeg: num('tilt', 0),
        twistOffsetDeg: num('twist', 0),
        randomTwistJitterDeg: num('jitter', 0),
        maxMeshEstimate: num('max', 25000)
      };
    }

    function writeParams(params){
      const p = new URLSearchParams();
      p.set('depth', params.depth);
      p.set('angle', params.arcAngleDeg);
      p.set('step', params.branchAzimuthDeg);
      p.set('bps', params.branchesPerSplit);
      p.set('lock', params.lockBranchesToAzimuth ? '1':'0');
      p.set('preset', params.scalePreset);
      p.set('scale', params.scalePerLevel.toFixed(6));
      p.set('thick', params.thickness);
      p.set('r0', params.radiusStart);
      p.set('seg', params.tubularSegments);
      p.set('sides', params.radialSegments);
      p.set('tilt', params.tiltDeg);
      p.set('twist', params.twistOffsetDeg);
      p.set('jitter', params.randomTwistJitterDeg);
      p.set('max', params.maxMeshEstimate);
      return `${location.origin}${location.pathname}?${p.toString()}`;
    }

    // ---------- Scene setup ----------
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e13);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(5, 5, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.target.set(0, 1.5, 0);

    scene.add(new THREE.HemisphereLight(0xbfd4ff, 0x22222a, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
    dirLight.position.set(6, 10, 6);
    scene.add(dirLight);

    const grid = new THREE.GridHelper(60, 60, 0x2b3140, 0x1a202c);
    grid.position.y = 0;
    scene.add(grid);

    const root = new THREE.Group();
    scene.add(root);

    // ---------- Rainbow material per level (discrete ROYGBIV so orange/yellow always appear) ----------
    const RAINBOW_HUES = [0, 30, 60, 120, 210, 275, 300];
    const levelMats = [];
    function getLevelMaterial(level){
      if (!levelMats[level]){
        const hue = RAINBOW_HUES[level % RAINBOW_HUES.length] / 360;
        const color = new THREE.Color().setHSL(hue, 0.9, 0.55);
        levelMats[level] = new THREE.MeshStandardMaterial({ color, metalness: 0.25, roughness: 0.5 });
      }
      return levelMats[level];
    }

    // ---------- Ratios ----------
    const PHI = (1 + Math.sqrt(5)) / 2;
    const SILVER = 1 + Math.SQRT2;
    const PLASTIC = 1.3247179572447458;

    // ---------- Parameters ----------
    const params = Object.assign({
      depth: 1,
      arcAngleDeg: 60,
      branchAzimuthDeg: 60,
      lockBranchesToAzimuth: true,
      branchesPerSplit: 6,
      scalePreset: 'phi^-1',
      scalePerLevel: 1/PHI,
      thickness: 0.1,
      radiusStart: 1.2,
      tubularSegments: 36,
      radialSegments: 10,
      tiltDeg: 0,
      twistOffsetDeg: 0,
      randomTwistJitterDeg: 0,
      maxMeshEstimate: 25000
    }, readParams());

    // ---------- GUI ----------
    const gui = new GUI({ title: 'Arc‑Fractal Tree' });
    const gStruct = gui.addFolder('Structure');
    const depthCtrl = gStruct.add(params, 'depth', 0, 7, 1).name('Depth');
    const arcCtrl   = gStruct.add(params, 'arcAngleDeg', 5, 150, 1).name('Arc angle (°)');
    const azCtrl    = gStruct.add(params, 'branchAzimuthDeg', 5, 180, 1).name('Azimuth step (°)');
    const lockCtrl  = gStruct.add(params, 'lockBranchesToAzimuth').name('Lock branches = 360/step');
    const bpsCtrl   = gStruct.add(params, 'branchesPerSplit', 1, 72, 1).name('Branches per split');

    const scaleOptions = [
      'phi^-1','phi^-2','phi^-3','phi^-4',
      'silver^-1','silver^-2','silver^-3','silver^-4',
      'plastic^-1','plastic^-2','plastic^-3','plastic^-4',
      'custom'
    ];
    const gScale = gui.addFolder('Scaling');
    const presetCtrl = gScale.add(params, 'scalePreset', scaleOptions).name('Scale preset');
    const scaleCtrl  = gScale.add(params, 'scalePerLevel', 0.1, 0.9, 0.0001).name('Scale per level');

    const gGeom = gui.addFolder('Geometry');
    gGeom.add(params, 'thickness', 0.02, 0.4, 0.005).name('Tube thickness');
    gGeom.add(params, 'radiusStart', 0.4, 3.0, 0.01).name('Start radius');
    gGeom.add(params, 'tubularSegments', 8, 128, 1).name('Arc segments');
    gGeom.add(params, 'radialSegments', 3, 24, 1).name('Tube sides');

    const gOrient = gui.addFolder('Orientation');
    gOrient.add(params, 'tiltDeg', -80, 80, 1).name('Tilt (°)');
    gOrient.add(params, 'twistOffsetDeg', 0, 360, 1).name('Twist offset (°)');
    gOrient.add(params, 'randomTwistJitterDeg', 0, 90, 1).name('Twist jitter (°)');

    function applyScalePreset(){
      const k = params.scalePreset;
      if (k === 'custom') return; // keep manual value
      const [name, powStr] = k.split('^-');
      const p = Math.max(1, parseInt(powStr||'1',10));
      const base = name === 'phi' ? PHI : (name === 'silver' ? SILVER : (name === 'plastic' ? PLASTIC : PHI));
      params.scalePerLevel = 1 / (base ** p);
      scaleCtrl.updateDisplay();
    }

    function syncBranchesLock(){
      if (params.lockBranchesToAzimuth){
        params.branchesPerSplit = Math.max(1, Math.floor(360 / Math.max(5, params.branchAzimuthDeg)));
        bpsCtrl.updateDisplay(); bpsCtrl.disable();
      } else {
        bpsCtrl.enable();
      }
    }

    [depthCtrl, arcCtrl].forEach(ctrl=>ctrl.onChange(()=>{ buildTree(); }))
    azCtrl.onChange(()=>{ syncBranchesLock(); buildTree(); });
    lockCtrl.onChange(()=>{ syncBranchesLock(); buildTree(); });
    bpsCtrl.onChange(()=>{ buildTree(); });
    presetCtrl.onChange(()=>{ applyScalePreset(); buildTree(); });
    scaleCtrl.onChange(()=>{ buildTree(); });
    gGeom.onChange(()=>{ buildTree(); });
    gOrient.onChange(()=>{ buildTree(); });

    document.getElementById('resetBtn').addEventListener('click', ()=>{
      camera.position.set(5, 5, 10);
      controls.target.set(0, 1.5, 0);
      controls.update();
    });

    document.getElementById('shareBtn').addEventListener('click', async ()=>{
      const url = writeParams(params);
      try {
        await navigator.clipboard.writeText(url);
        alert('Sharable link copied to clipboard!');
      } catch {
        prompt('Copy this link:', url);
      }
    });

    document.getElementById('randomBtn').addEventListener('click', ()=>{
      // gentle randomization within safe ranges
      params.arcAngleDeg = Math.round(THREE.MathUtils.randFloat(30, 100));
      params.branchAzimuthDeg = Math.round(THREE.MathUtils.randFloat(15, 120));
      params.lockBranchesToAzimuth = true;
      params.tiltDeg = Math.round(THREE.MathUtils.randFloat(-30, 30));
      params.twistOffsetDeg = Math.round(THREE.MathUtils.randFloat(0, 360));
      params.randomTwistJitterDeg = Math.round(THREE.MathUtils.randFloat(0, 25));
      const presets = ['phi^-1','phi^-2','silver^-1','plastic^-1'];
      params.scalePreset = presets[Math.floor(Math.random()*presets.length)];
      applyScalePreset(); syncBranchesLock();
      gui.controllersRecursive().forEach(c=>c.updateDisplay?.());
      buildTree();
    });

    document.getElementById('aboutLink').addEventListener('click', (e)=>{
      e.preventDefault();
      alert('Arc‑Fractal Tree\n\n• Arcs instead of straight segments\n• Branch around the parent tangent\n• φ / silver / plastic scaling presets\n• Press S to save a PNG\n\nTip: use the Share link to send your exact settings.');
    });

    // ---------- Math helpers ----------
    function orthonormalize(T, N){
      const t = T.clone().normalize();
      let n = N.clone().sub(t.clone().multiplyScalar(t.dot(N)));
      if (n.lengthSq() < 1e-9){
        const tmp = Math.abs(t.x) < 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
        n = tmp.sub(t.clone().multiplyScalar(t.dot(tmp)));
      }
      n.normalize();
      const u = new THREE.Vector3().crossVectors(n, t).normalize();
      return { t, n, u };
    }

    function quatFromTN(T, N){
      const { t, n } = orthonormalize(T, N);
      const y = new THREE.Vector3().crossVectors(n, t).normalize();
      const m = new THREE.Matrix4();
      m.makeBasis(t, y, n); // X=tangent, Y=binormal, Z=normal
      return new THREE.Quaternion().setFromRotationMatrix(m);
    }

    class LocalArcCurve extends THREE.Curve {
      constructor(radius=1, angleRad=Math.PI/3){ super(); this.r = radius; this.a = angleRad; }
      getPoint(t){
        const a = this.a * t; // 0..angle
        return new THREE.Vector3( this.r*Math.sin(a), this.r*(1 - Math.cos(a)), 0 );
      }
      getTangent(t){
        const a = this.a * t;
        return new THREE.Vector3(Math.cos(a), Math.sin(a), 0).normalize();
      }
    }

    function clear(obj){
      for (let i = obj.children.length - 1; i >= 0; i--) {
        const c = obj.children[i];
        c.geometry && c.geometry.dispose && c.geometry.dispose();
        obj.remove(c);
      }
    }

    function addArc(P, T, N, radius, arcAngleRad, tubeRadius, tubularSegments, radialSegments, azimuthDeg=0, tiltDeg=0, level=0){
      const { t: Tn, n: N0 } = orthonormalize(T, N);
      const qAz = new THREE.Quaternion().setFromAxisAngle(Tn, THREE.MathUtils.degToRad(azimuthDeg));
      const N_az = N0.clone().applyQuaternion(qAz);
      const U_az = new THREE.Vector3().crossVectors(N_az, Tn).normalize();
      const qTilt = new THREE.Quaternion().setFromAxisAngle(U_az, THREE.MathUtils.degToRad(tiltDeg));
      const N_final = N_az.clone().applyQuaternion(qTilt);
      const qOrient = quatFromTN(Tn, N_final);

      const curve = new LocalArcCurve(radius, arcAngleRad);
      const geom = new THREE.TubeGeometry(curve, Math.max(2, tubularSegments|0), tubeRadius, Math.max(3, radialSegments|0), false);
      const mesh = new THREE.Mesh(geom, getLevelMaterial(level));
      mesh.quaternion.copy(qOrient);
      mesh.position.copy(P);
      root.add(mesh);

      const endLocal = curve.getPoint(1).clone();
      const tanLocal = curve.getTangent(1).clone();
      const endWorld = endLocal.applyQuaternion(qOrient).add(P);
      const tanWorld = tanLocal.applyQuaternion(qOrient).normalize();
      const normalWorld = new THREE.Vector3(0,0,1).applyQuaternion(qOrient).normalize();

      return { end: endWorld, dir: tanWorld, normal: normalWorld };
    }

    function estimateMeshes(depth, bps){
      let total = 1; // trunk
      let pow = 1;
      for (let i=1; i<=depth; i++) { pow *= bps; total += pow; }
      return total;
    }

    function buildTree(){
      clear(root);
      applyScalePreset();
      syncBranchesLock();

      const depth = Math.min(7, params.depth|0); // clamp for safety
      const branchStepDeg = Math.max(5, params.branchAzimuthDeg);
      const branchesPerSplit = params.lockBranchesToAzimuth
        ? Math.max(1, Math.floor(360 / branchStepDeg))
        : (params.branchesPerSplit|0);

      const est = estimateMeshes(depth, branchesPerSplit);
      if (est > params.maxMeshEstimate){
        console.warn(`Build skipped: estimated ${est} meshes exceeds cap (${params.maxMeshEstimate}). Reduce depth or branches.`);
        return;
      }

      const arcAngleRad = THREE.MathUtils.degToRad(params.arcAngleDeg);
      const tubeBase = Math.max(0.005, params.thickness);
      const tubularSegments = params.tubularSegments|0;
      const radialSegments = params.radialSegments|0;
      const radius0 = Math.max(0.05, params.radiusStart);

      const stack = [];
      const startPos = new THREE.Vector3(0, 0.01, 0);
      const startT = new THREE.Vector3(0, 1, 0);
      const startN = new THREE.Vector3(0, 0, 1);

      const trunk = addArc(startPos, startT, startN, radius0, arcAngleRad, tubeBase, tubularSegments, radialSegments, 0, params.tiltDeg, 0);
      stack.push({level:1, P: trunk.end, T: trunk.dir, N: trunk.normal, r: radius0 * params.scalePerLevel, t: tubeBase * 0.9});

      while (stack.length){
        const node = stack.pop();
        const { level, P, T, N } = node;
        if (level > depth) continue;

        for (let i=0;i<branchesPerSplit;i++){
          const jitter = (Math.random()*2-1) * params.randomTwistJitterDeg;
          const az = params.twistOffsetDeg + i * branchStepDeg + jitter;
          const seg = addArc(P, T, N, node.r, arcAngleRad, Math.max(0.002, node.t), tubularSegments, radialSegments, az, params.tiltDeg, level);
          stack.push({level: level + 1, P: seg.end, T: seg.dir, N: seg.normal, r: node.r * params.scalePerLevel, t: node.t * params.scalePerLevel * 0.92});
        }
      }
    }

    // Initial build
    buildTree();

    // Keep URL in sync on changes (debounced)
    let syncTimer;
    function syncUrl(){
      clearTimeout(syncTimer);
      syncTimer = setTimeout(()=>{
        const url = writeParams(params);
        history.replaceState(null, '', url);
      }, 250);
    }
    gui.onChange(()=>{ buildTree(); syncUrl(); });

    // Resize & render loop
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase() === 's') {
        const a = document.createElement('a');
        a.href = renderer.domElement.toDataURL('image/png');
        a.download = 'arc-fractal-tree.png';
        a.click();
      }
    });
    renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene, camera); });
  </script>
</body>
</html>
