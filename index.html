<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arc-Fractal Tree — Welded Pivots (Presets + Color FX)</title>
  <meta name="description" content="Arc-fractal tree with welded joints, per-level counter-rotation, presets, rainbow gradients per depth, and a white traveling pulse." />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background:#0b0e13; color:#e7eaee; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; }
    .overlay { position: fixed; left: 12px; top: 12px; z-index: 10; display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .btn { appearance:none; border:1px solid #2a3240; background:#12161c; color:#dfe6f1; padding:6px 10px; border-radius:10px; cursor:pointer; font-size:12px }
    .btn:hover{ background:#161c24; }
    .hint { position: fixed; left: 12px; bottom: 12px; opacity: 0.75; font-size: 12px; }
    .brand { position: fixed; right: 12px; bottom: 12px; opacity: 0.8; font-size: 12px; color:#b9c0c9; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "lil-gui": "https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="overlay">
    <button id="resetBtn" class="btn">Reset view</button>
  </div>
  <div class="hint">Drag = orbit · Shift+Drag = pan · Wheel/pinch = zoom · Press <b>S</b> to save a PNG</div>
  <div class="brand">Arc-Fractal Tree · Three.js</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import GUI from 'lil-gui';

    // ---------- Scene ----------
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e13);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(5, 5, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.target.set(0, 1.5, 0);

    scene.add(new THREE.HemisphereLight(0xbfd4ff, 0x22222a, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
    dirLight.position.set(6, 10, 6);
    scene.add(dirLight);

    const grid = new THREE.GridHelper(60, 60, 0x2b3140, 0x1a202c);
    grid.position.y = 0;
    scene.add(grid);

    const root = new THREE.Group();
    scene.add(root);

    // ---------- Color system / presets ----------
    const RAINBOW_HUES = [0, 30, 60, 120, 210, 275, 300]; // base per-level hues
    let hueShiftDeg = 0;   // animated hue drift (degrees)
    let pulsePos = 0;      // traveling pulse distance along path
    let totalPathLen = 1;  // updated at build

    function baseHueForLevel(level){
      return RAINBOW_HUES[level % RAINBOW_HUES.length];
    }

    // ---------- Math helpers ----------
    function orthonormalize(T, N){
      const t = T.clone().normalize();
      let n = N.clone().sub(t.clone().multiplyScalar(t.dot(N)));
      if (n.lengthSq() < 1e-9){
        const tmp = Math.abs(t.x) < 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
        n = tmp.sub(t.clone().multiplyScalar(t.dot(tmp)));
      }
      n.normalize();
      const u = new THREE.Vector3().crossVectors(n, t).normalize();
      return { t, n, u };
    }
    function quatFromTN(T, N){
      const { t, n } = orthonormalize(T, N);
      const y = new THREE.Vector3().crossVectors(n, t).normalize();
      const m = new THREE.Matrix4();
      m.makeBasis(t, y, n); // X=tangent, Y=binormal, Z=normal
      return new THREE.Quaternion().setFromRotationMatrix(m);
    }

    class LocalArcCurve extends THREE.Curve {
      constructor(radius=1, angleRad=Math.PI/3){ super(); this.r = radius; this.a = angleRad; }
      getPoint(t){ const a = this.a * t; return new THREE.Vector3(this.r*Math.sin(a), this.r*(1 - Math.cos(a)), 0); }
      getTangent(t){ const a = this.a * t; return new THREE.Vector3(Math.cos(a), Math.sin(a), 0).normalize(); }
    }

    // ---------- Params & GUI ----------
    const PHI = (1 + Math.sqrt(5)) / 2;
    const SILVER = 1 + Math.SQRT2;
    const PLASTIC = 1.3247179572447458;

    const params = {
      // Presets
      preset: 'Phi 120',

      // Structure
      depth: 6,
      arcAngleDeg: 120,
      branchAzimuthDeg: 120,
      lockBranchesToAzimuth: true,
      branchesPerSplit: 3,

      // Scaling
      scalePreset: 'phi^-1',
      scalePerLevel: 1/PHI,

      // Geometry
      thickness: 0.035,
      radiusStart: 1.2,
      tubularSegments: 36,
      radialSegments: 10,

      // Safety
      maxMeshEstimate: 100000,

      // Color animation (global)
      colorDrift: true,                // ON at load
      colorDriftSpeed: 2.0,            // default 2, slider up to 5

      // Color modes
      colorMode: 'Solid',              // 'Solid' | 'Rainbow (depth)' | 'White pulse'
      rainbowSpanDeg: 180,             // hue sweep along segment (for Rainbow mode)
      pulseSpeed: 3.0,                 // path units per second
      pulseWidth: 0.6,                 // band width in path units

      // Motion
      spinRoot: true,                  // ON at load
      spinSpeedDegPerSec: 24,          // base speed

      // Hierarchical per-level spin
      perLevelCounterSpin: true,
      alternateSpinDir: true,          // (+, -, +, -, ...) by level

      // Visualize welds
      showJoints: false,
      jointSize: 0.03
    };

    const gui = new GUI({ title: 'Arc-Fractal Tree' });

    // Preset dropdown
    const gPresets = gui.addFolder('Presets');
    const presetCtrl = gPresets.add(params, 'preset', ['Custom','Phi 120','Phi 90','Phi 144','Phi 72','Silver 120']).name('Choose preset');

    const gStruct = gui.addFolder('Structure');
    const depthCtrl = gStruct.add(params, 'depth', 0, 7, 1).name('Depth');
    const arcCtrl   = gStruct.add(params, 'arcAngleDeg', 5, 150, 1).name('Arc angle (°)');
    const azCtrl    = gStruct.add(params, 'branchAzimuthDeg', 5, 180, 1).name('Azimuth step (°)');
    const lockCtrl  = gStruct.add(params, 'lockBranchesToAzimuth').name('Lock branches = 360/step');
    const bpsCtrl   = gStruct.add(params, 'branchesPerSplit', 1, 360, 1).name('Branches per split');

    const scaleOptions = [
      'phi^-1','phi^-2','phi^-3','phi^-4',
      'silver^-1','silver^-2','silver^-3','silver^-4',
      'plastic^-1','plastic^-2','plastic^-3','plastic^-4',
      'custom'
    ];
    const gScale = gui.addFolder('Scaling');
    const presetScaleCtrl = gScale.add(params, 'scalePreset', scaleOptions).name('Scale preset');
    const scaleCtrl       = gScale.add(params, 'scalePerLevel', 0.1, 0.9, 0.0001).name('Scale per level');

    const gGeom = gui.addFolder('Geometry');
    gGeom.add(params, 'thickness', 0.01, 0.5, 0.001).name('Tube thickness');
    gGeom.add(params, 'radiusStart', 0.2, 4.0, 0.01).name('Start radius');
    gGeom.add(params, 'tubularSegments', 8, 128, 1).name('Arc segments');
    gGeom.add(params, 'radialSegments', 3, 24, 1).name('Tube sides');

    const gColor = gui.addFolder('Color');
    gColor.add(params, 'colorDrift').name('Enable color drift');
    gColor.add(params, 'colorDriftSpeed', 0.05, 5.0, 0.05).name('Drift speed');
    gColor.add(params, 'colorMode', ['Solid','Rainbow (depth)','White pulse']).name('Color mode').onChange(updateModeUniforms);
    gColor.add(params, 'rainbowSpanDeg', 0, 360, 1).name('Rainbow span (°)').onChange(updateModeUniforms);
    gColor.add(params, 'pulseSpeed', 0.1, 20.0, 0.1).name('Pulse speed').onChange(updateModeUniforms);
    gColor.add(params, 'pulseWidth', 0.01, 5.0, 0.01).name('Pulse width').onChange(updateModeUniforms);

    const gMotion = gui.addFolder('Motion');
    gMotion.add(params, 'spinRoot').name('Spin root (global)');
    gMotion.add(params, 'perLevelCounterSpin').name('Per-level spin (hier)');
    gMotion.add(params, 'alternateSpinDir').name('Alternate direction');
    gMotion.add(params, 'spinSpeedDegPerSec', 1, 180, 1).name('Base speed (°/s)');

    const gJoints = gui.addFolder('Joints');
    gJoints.add(params, 'showJoints').name('Show joints').onChange(buildTree);
    gJoints.add(params, 'jointSize', 0.005, 0.2, 0.001).name('Joint size').onChange(buildTree);

    function applyScalePreset(){
      const k = params.scalePreset;
      if (k === 'custom') return;
      const [name, powStr] = k.split('^-');
      const p = Math.max(1, parseInt(powStr||'1',10));
      const base = name === 'phi' ? PHI : (name === 'silver' ? SILVER : (name === 'plastic' ? PLASTIC : PHI));
      params.scalePerLevel = 1 / (base ** p);
      scaleCtrl.updateDisplay();
    }
    function syncBranchesLock(){
      if (params.lockBranchesToAzimuth){
        params.branchesPerSplit = Math.max(1, Math.floor(360 / Math.max(5, params.branchAzimuthDeg)));
        bpsCtrl.updateDisplay(); bpsCtrl.disable();
      } else { bpsCtrl.enable(); }
    }
    function refreshDisplays(){
      [depthCtrl, arcCtrl, azCtrl, lockCtrl, bpsCtrl, scaleCtrl].forEach(c=>c.updateDisplay && c.updateDisplay());
    }
    function applyPresetByName(name){
      if (name === 'Phi 120'){
        params.depth = 7; params.arcAngleDeg = 120; params.branchAzimuthDeg = 120;
        params.lockBranchesToAzimuth = true; params.scalePreset = 'phi^-1';
        params.thickness = 0.04;
      } else if (name === 'Phi 90'){
        params.depth = 6; params.arcAngleDeg = 90; params.branchAzimuthDeg = 90;
        params.lockBranchesToAzimuth = true; params.scalePreset = 'phi^-1';
        params.thickness = 0.02;
      } else if (name === 'Phi 144'){
        params.depth = 6; params.arcAngleDeg = 144; params.branchAzimuthDeg = 72;
        params.lockBranchesToAzimuth = true; params.scalePreset = 'phi^-2';
        params.thickness = 0.04;
      } else if (name === 'Phi 72'){
        params.depth = 7; params.arcAngleDeg = 72; params.branchAzimuthDeg = 120;
        params.lockBranchesToAzimuth = true; params.scalePreset = 'phi^-1';
        params.thickness = 0.02;
      } else if (name === 'Silver 120'){
        params.depth = 5; params.arcAngleDeg = 120; params.branchAzimuthDeg = 60;
        params.lockBranchesToAzimuth = true; params.scalePreset = 'silver^-1';
        params.thickness = 0.04;
      }
      applyScalePreset(); syncBranchesLock(); refreshDisplays(); buildTree();
    }
    presetCtrl.onChange(v=>{ if (v !== 'Custom') applyPresetByName(v); });

    [depthCtrl, arcCtrl].forEach(c=>c.onChange(buildTree));
    azCtrl.onChange(()=>{ syncBranchesLock(); buildTree(); });
    lockCtrl.onChange(()=>{ syncBranchesLock(); buildTree(); });
    bpsCtrl.onChange(buildTree);
    presetScaleCtrl.onChange(()=>{ applyScalePreset(); buildTree(); });
    scaleCtrl.onChange(buildTree);
    gGeom.onChange(buildTree);

    document.getElementById('resetBtn').addEventListener('click', ()=>{
      camera.position.set(5, 5, 10);
      controls.target.set(0, 1.5, 0);
      controls.update();
    });

    // ---------- Build primitives (LOCAL-SPACE ONLY) ----------
    const Y_UNIT = new THREE.Vector3(0,1,0);
    const Z_UNIT = new THREE.Vector3(0,0,1);
    let spinners = [];           // { pivot, level }
    let dynamicMats = [];        // MeshStandardMaterials we update each frame
    const jointGeom = new THREE.SphereGeometry(1, 16, 12);
    const jointMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

    function clearObj(obj){
      for (let i = obj.children.length - 1; i >= 0; i--) {
        const c = obj.children[i];
        if (c.children) clearObj(c);
        c.geometry && c.geometry.dispose && c.geometry.dispose();
        obj.remove(c);
      }
    }
    function estimateMeshes(depth, bps){ let total = 1, pow = 1; for (let i=1; i<=depth; i++){ pow *= bps; total += pow; } return total; }

    // Shader-augmented StandardMaterial (keeps lighting), with UV access + color modes
    function makeColorMaterial(level, startDist, segLen){
      const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.25, roughness: 0.5 });
      const baseHueDeg = baseHueForLevel(level);

      mat.onBeforeCompile = (shader)=>{
        // uniforms
        shader.uniforms.uTime        = { value: 0 };
        shader.uniforms.uHueShift    = { value: 0 };               // deg
        shader.uniforms.uBaseHueDeg  = { value: baseHueDeg };      // deg
        shader.uniforms.uLevel       = { value: level };
        shader.uniforms.uStartDist   = { value: startDist };
        shader.uniforms.uSegLen      = { value: segLen };
        shader.uniforms.uMode        = { value: colorModeToIndex(params.colorMode) };
        shader.uniforms.uRainbowSpan = { value: params.rainbowSpanDeg }; // deg
        shader.uniforms.uPulsePos    = { value: pulsePos };
        shader.uniforms.uPulseWidth  = { value: params.pulseWidth };

        // ensure vUv available
        shader.vertexShader   = 'varying vec2 vUv;\n' + shader.vertexShader.replace('void main() {','void main(){\n  vUv = uv;');
        shader.fragmentShader = `
          varying vec2 vUv;
          uniform float uTime;
          uniform float uHueShift;
          uniform float uBaseHueDeg;
          uniform float uLevel;
          uniform float uStartDist;
          uniform float uSegLen;
          uniform int   uMode;
          uniform float uRainbowSpan;
          uniform float uPulsePos;
          uniform float uPulseWidth;

          vec3 hsl2rgb(vec3 hsl){
            float h = hsl.x, s = hsl.y, l = hsl.z;
            float c = (1.0 - abs(2.0*l - 1.0)) * s;
            float hp = mod(h*6.0, 6.0);
            float x = c * (1.0 - abs(mod(hp,2.0) - 1.0));
            vec3 rgb;
            if (0.0 <= hp && hp < 1.0)      rgb = vec3(c,x,0);
            else if (1.0 <= hp && hp < 2.0) rgb = vec3(x,c,0);
            else if (2.0 <= hp && hp < 3.0) rgb = vec3(0,c,x);
            else if (3.0 <= hp && hp < 4.0) rgb = vec3(0,x,c);
            else if (4.0 <= hp && hp < 5.0) rgb = vec3(x,0,c);
            else                            rgb = vec3(c,0,x);
            float m = l - 0.5*c;
            return rgb + m;
          }
        ` + shader.fragmentShader;

        // Inject after diffuseColor is defined
        shader.fragmentShader = shader.fragmentShader.replace(
          'vec4 diffuseColor = vec4( diffuse, opacity );',
          `
            vec4 diffuseColor = vec4( diffuse, opacity );

            float v = clamp(vUv.y, 0.0, 1.0);

            // Base HSL
            float hue = mod((uBaseHueDeg + uHueShift) / 360.0, 1.0);
            float sat = 0.90;
            float lit = 0.55;

            if (uMode == 1) {
              // Rainbow gradient per depth
              hue = mod(hue + (uRainbowSpan/360.0) * v, 1.0);
            }
            vec3 col = hsl2rgb(vec3(hue, sat, lit));

            if (uMode == 2) {
              // Traveling white pulse along global path distance
              float distAlong = uStartDist + v * uSegLen;
              float w = smoothstep(uPulseWidth, 0.0, abs(distAlong - uPulsePos));
              col = mix(col, vec3(1.0), w);
            }

            diffuseColor.rgb = col;
          `
        );

        mat.userData.shader = shader;
      };

      dynamicMats.push(mat);
      return mat;
    }

    function colorModeToIndex(mode){
      return mode === 'Rainbow (depth)' ? 1 : (mode === 'White pulse' ? 2 : 0);
    }
    function updateModeUniforms(){
      const idx = colorModeToIndex(params.colorMode);
      for (const m of dynamicMats){
        const sh = m.userData.shader;
        if (!sh) continue;
        sh.uniforms.uMode.value = idx;
        sh.uniforms.uRainbowSpan.value = params.rainbowSpanDeg;
        sh.uniforms.uPulseWidth.value  = params.pulseWidth;
      }
    }

    // Build one arc mesh under 'parent' in LOCAL space; returns end/tangent in mesh local.
    function addArcLocal(parent, P_local, T_local, N_local, radius, arcAngleRad, tubeRadius, tubularSegments, radialSegments, level, startDist){
      const { t: Tn, n: Nn } = orthonormalize(T_local, N_local);
      const qOrient = quatFromTN(Tn, Nn);

      const curve = new LocalArcCurve(radius, arcAngleRad);
      const geom = new THREE.TubeGeometry(curve, Math.max(2, tubularSegments|0), tubeRadius, Math.max(3, radialSegments|0), false);

      const segLen = radius * arcAngleRad; // constant-speed arc
      const mat = makeColorMaterial(level, startDist, segLen);

      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(P_local);
      mesh.quaternion.copy(qOrient);
      parent.add(mesh);

      const endLocal = curve.getPoint(1).clone();
      const tanLocal = curve.getTangent(1).clone();

      // track max path length
      totalPathLen = Math.max(totalPathLen, startDist + segLen);

      return { mesh, endLocal, tanLocal, segLen };
    }

    // Create pivot as CHILD of segment at its local end; +Y aligned to local tangent.
    function makeChildPivotOnSegment(segmentMesh, endLocal, tanLocal, level){
      const pivot = new THREE.Group();
      pivot.position.copy(endLocal);
      const q = new THREE.Quaternion().setFromUnitVectors(Y_UNIT, tanLocal.clone().normalize());
      pivot.quaternion.copy(q);
      segmentMesh.add(pivot);

      spinners.push({ pivot, level });

      if (params.showJoints){
        const s = new THREE.Mesh(jointGeom, jointMat);
        s.scale.setScalar(params.jointSize);
        pivot.add(s);
      }
      return pivot;
    }

    function buildTree(){
      clearObj(root);
      spinners = [];
      dynamicMats = [];
      totalPathLen = 0;

      const depth = Math.min(7, params.depth|0);
      const branchStepDeg = Math.max(5, params.branchAzimuthDeg);
      const branchesPerSplit = params.lockBranchesToAzimuth
        ? Math.max(1, Math.floor(360 / Math.max(5, params.branchAzimuthDeg)))
        : (params.branchesPerSplit|0);

      const est = estimateMeshes(depth, branchesPerSplit);
      if (est > params.maxMeshEstimate){
        console.warn(`Build skipped: estimated ${est} meshes exceeds cap (${params.maxMeshEstimate}). Lower depth/branches or increase cap.`);
        return;
      }

      const arcAngleRad = THREE.MathUtils.degToRad(params.arcAngleDeg);
      const tubeBase = Math.max(0.003, params.thickness);
      const tubularSegments = params.tubularSegments|0;
      const radialSegments = params.radialSegments|0;
      const radius0 = Math.max(0.05, params.radiusStart);

      // Trunk (level 0)
      const startLocal = new THREE.Vector3(0, 0.01, 0);
      const trunk = addArcLocal(root, startLocal, Y_UNIT, Z_UNIT, radius0, arcAngleRad, tubeBase, tubularSegments, radialSegments, 0, /*startDist*/0);

      // Pivot on trunk end for level-1 branches
      const trunkPivot = makeChildPivotOnSegment(trunk.mesh, trunk.endLocal, trunk.tanLocal, 1);

      const stack = [];
      stack.push({
        level: 1,
        parentPivot: trunkPivot,
        r: radius0 * params.scalePerLevel,
        t: tubeBase * 0.9,
        arcAngleRad,
        startDist: trunk.segLen
      });

      while (stack.length){
        const node = stack.pop();
        const { level, parentPivot, r, t, arcAngleRad, startDist } = node;
        if (level > depth) continue;

        for (let i=0; i<branchesPerSplit; i++){
          const jitter = 0; // keep deterministic orientation (your tilt stays internal at 0)
          const azDeg = i * branchStepDeg + jitter + 0 + 0; // (twistOffsetDeg & random jitter removed from UI)

          // pivot-local orientation: T=+Y, base N=+Z
          const qAz = new THREE.Quaternion().setFromAxisAngle(Y_UNIT, THREE.MathUtils.degToRad(azDeg));
          const N_az = Z_UNIT.clone().applyQuaternion(qAz);
          const U_az = new THREE.Vector3().crossVectors(N_az, Y_UNIT).normalize();
          const qTilt = new THREE.Quaternion().setFromAxisAngle(U_az, THREE.MathUtils.degToRad(0));
          const N_final = N_az.clone().applyQuaternion(qTilt);

          // Child arc at pivot origin, with startDist propagated
          const seg = addArcLocal(parentPivot, new THREE.Vector3(0,0,0), Y_UNIT, N_final, r, arcAngleRad, Math.max(0.002, t), tubularSegments, radialSegments, level, startDist);

          const childPivot = makeChildPivotOnSegment(seg.mesh, seg.endLocal, seg.tanLocal, level + 1);

          stack.push({
            level: level + 1,
            parentPivot: childPivot,
            r: r * params.scalePerLevel,
            t: t * params.scalePerLevel * 0.92,
            arcAngleRad,
            startDist: startDist + seg.segLen
          });
        }
      }

      // update uniforms that depend on mode immediately
      updateModeUniforms();
    }

    // Initial build
    function initFromPreset(){
      if (params.preset !== 'Custom') applyPresetByName(params.preset);
      else { syncBranchesLock(); applyScalePreset(); buildTree(); }
    }
    initFromPreset();

    // Resize & loop
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase() === 's') {
        const a = document.createElement('a');
        a.href = renderer.domElement.toDataURL('image/png');
        a.download = 'arc-fractal-tree.png';
        a.click();
      }
    });

    let _last = performance.now();
    renderer.setAnimationLoop(()=>{
      const now = performance.now();
      const dt = Math.max(0, (now - _last) / 1000);
      _last = now;

      // Color drift: animate hue shift (deg)
      if (params.colorDrift) {
        hueShiftDeg = (hueShiftDeg + params.colorDriftSpeed) % 360;
      }

      // Global spin
      if (params.spinRoot) {
        root.rotation.y += THREE.MathUtils.degToRad(params.spinSpeedDegPerSec) * dt;
      }

      // Hierarchical per-level spin
      if (params.perLevelCounterSpin) {
        const base = THREE.MathUtils.degToRad(params.spinSpeedDegPerSec);
        for (const s of spinners){
          const factor = (s.level + 1);
          const dir = params.alternateSpinDir ? ((s.level % 2) ? -1 : 1) : 1;
          s.pivot.rotateOnAxis(Y_UNIT, base * factor * dir * dt);
        }
      }

      // White pulse progression
      const modeIdx = colorModeToIndex(params.colorMode);
      if (modeIdx === 2) {
        pulsePos = (pulsePos + params.pulseSpeed * dt);
        if (pulsePos > totalPathLen) pulsePos = pulsePos - totalPathLen; // wrap
      }

      // Push uniforms to all dynamic materials
      for (const m of dynamicMats){
        const sh = m.userData.shader;
        if (!sh) continue;
        sh.uniforms.uTime.value        = now * 0.001;
        sh.uniforms.uHueShift.value    = hueShiftDeg;
        sh.uniforms.uMode.value        = modeIdx;
        sh.uniforms.uRainbowSpan.value = params.rainbowSpanDeg;
        sh.uniforms.uPulsePos.value    = pulsePos;
        sh.uniforms.uPulseWidth.value  = params.pulseWidth;
      }

      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
